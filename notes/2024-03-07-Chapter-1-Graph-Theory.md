# Chapter 1 | The Beauty of Graph Theory

```{article-info}
:avatar: https://avatars.githubusercontent.com/u/63636498?v=4
:avatar-link: https://github.com/ABD-01
:avatar-outline: muted
:author: Muhammed Abdullah
:date: March 07, 2024
:read-time: "{sub-ref}`wordcount-minutes` min read"
```

﻿[03:07](https://youtu.be/oXcCAAEDte0?t=187)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_7fef8761-55ed-47d2-9aed-5684f8272e0a.jpeg)


﻿[03:05](https://youtu.be/oXcCAAEDte0?t=185)﻿

but important the degree of a node doesn't always represent the number of neighbors of a Noe this is only the case if there isn't more than one Edge between two nodes


﻿[04:02](https://youtu.be/oXcCAAEDte0?t=242)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_c5723cf6-e791-434c-85ac-9cc92bd40c11.jpeg)

Sum of degrees of all nodes is ALWAYS **EVEN**

﻿[04:36](https://youtu.be/oXcCAAEDte0?t=276)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_3d0c79a9-1527-4ab2-b8bc-2d96c0f9cb80.jpeg)

this graph is complete graph (every node is connected to all other nodes except itself.) has 57 nodes.

Hence every node is connected to (57-1=)56 other nodes. Sum of all degrees is 57x56 = 3192.


﻿[04:47](https://youtu.be/oXcCAAEDte0?t=287)﻿

the total number of edges in this graph is given by half this number because by summing up all degrees one counts every single edge twice this lets us to suspect that the sum of all degrees in the graph is always equal to twice the number of edges in the graph.

The formula:

﻿[05:48](https://youtu.be/oXcCAAEDte0?t=348)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_59655e34-86cb-439b-b3b6-4686989af6d2.jpeg)

  

﻿[05:57](https://youtu.be/oXcCAAEDte0?t=357)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_e25e7ef9-505b-4992-9ec5-1a1dec74a20a.jpeg)

  

﻿[05:50](https://youtu.be/oXcCAAEDte0?t=350)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_016b3edc-48f1-4afa-a5f0-6d0f22c7018e.jpeg)

  

﻿[06:13](https://youtu.be/oXcCAAEDte0?t=373)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_aaa065fb-cbf1-4d96-914d-142728cf103e.jpeg)

  

Corollary:

﻿[06:23](https://youtu.be/oXcCAAEDte0?t=383)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_0ceed61c-b511-407c-8563-f72bb2ebc5a5.jpeg)

  

  

## Graph Traversal

**BFS** \- starts at a node and visits all its it's neighbors. Layer by layer exploration of graph.

  

﻿[07:15](https://youtu.be/oXcCAAEDte0?t=435)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_c69a56e1-ae5c-4522-96ab-5183f9b3de45.jpeg)

The subgraph generated by this algorithm is known as BFS tree:

  

﻿[07:32](https://youtu.be/oXcCAAEDte0?t=452)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_461554e4-4170-4d64-b023-c2a45287bbfe.jpeg)

  

﻿[07:16](https://youtu.be/oXcCAAEDte0?t=436)﻿

the subgraph generated by this algorithm is known as a bfs tree which offers valuable information about the underlying graph:

1) for instance shortest paths from the starting nodes to all other nodes

2) if the length of a path is characterized by the number of its edges.

  

**DFS** - the algorithm follows the approach to explore the graph in depth first. It selects in every iteration a neighbor node possibly a random neighbor as the next node and continues in this way until it gets stuck then the natural way out think about a maze is to backtrack to the last note with unvisited notes in its neighborhood.

﻿[08:16](https://youtu.be/oXcCAAEDte0?t=496)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_5cac49a6-2086-4b8e-8922-b6511c37f128.jpeg)

  

﻿[08:20](https://youtu.be/oXcCAAEDte0?t=500)﻿

The resulting subgraph the DFS Tree looks a bit familiar to a maze and indeed with the right modifications this simple algorithm can also be used to generate a maze.

  

**Creating Maze using DFS**

﻿[09:17](https://youtu.be/oXcCAAEDte0?t=557)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_281584a9-239f-4d40-bcba-d4968f6e8f76.jpeg)

  

﻿[09:44](https://youtu.be/oXcCAAEDte0?t=584)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_b4ed4713-feb8-4011-8ebb-b0c944d44a2c.jpeg)

  

  

﻿[09:31](https://youtu.be/oXcCAAEDte0?t=571)﻿

Note that through the application of DFS this maze has a solution. Since DFS ﻿[09:33](https://youtu.be/oXcCAAEDte0?t=573)﻿calculates a path from the starting nodes to all notes in the graph. In other words there is a path from the starting notes to any other nodes here.

  

Example: Electricity Wire distribution in city

﻿[10:25](https://youtu.be/oXcCAAEDte0?t=625)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_653e2417-262a-44a7-aca6-6b3174a4e9f8.jpeg)

  

﻿[10:49](https://youtu.be/oXcCAAEDte0?t=649)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_75f8e673-0063-4c29-9e14-f002331337ad.jpeg)

  

﻿[10:39](https://youtu.be/oXcCAAEDte0?t=639)﻿

the distribution of wires such that every town gets access to electricity therefore one would search for a minimum spending tree in the given graph which is a spanning tree with the least possible total cost.

  

  

## Shortest Path Algorithms

﻿[10:43](https://youtu.be/oXcCAAEDte0?t=643)﻿

Very important in graph Theory especially in the era of navigation systems like Google Map maps are shortest path algorithms. Think about a map of country where each note represents a city and the edges are labeled with costs such as the kilometer distances between two nodes or the duration to travel between two adjacent nodes.

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_c1ee5939-e11a-4602-87b7-28be1cbfaebe.jpeg)

  
## The Origin of Graph Theory

﻿[12:42](https://youtu.be/oXcCAAEDte0?t=762)﻿

The citizens decided to create a game for themselves. Their goal being to devise a way which they could walk around the city crossing each of the Seven Bridges in Koenigsberg exactly once.

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_82cf59f7-a963-47f0-b9e6-6f07c0cbca62.jpeg)


### Seven Bridges in Koenigsberg

### Walk

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_d2ced1bb-90b1-4ac5-9921-a5cdcc0758d4.jpeg)

  

Definitions

### Path

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_61e3f02f-65fe-4707-b849-8df15ac59df9.jpeg)

A path is a walk in a graph such that all visited nodes in the walk are distinct. So in the general definition of a path, it is not allowed to use nodes more than once.

### Cycle

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_b81bbefc-da6c-4ba7-8ebb-1cbe8cf18520.jpeg)

A cycle is a path that is closed meaning it starts and stops at the same at the same nodes. Furthermore, the length of a cycle is given by the number of used edges in cycle.

### Trail

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_cb5ee935-e025-42d3-91bc-3db5e0a8eb31.jpeg)

A trail is a walk such that all used edges are distinct. Furthermore, it can visit notes more than once.

### Circuit

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_b94026cd-cd00-4a2a-ae9f-b710a72d6968.jpeg)

A circuit (not to confuse with a cycle important) is a closed trail.

### Euler Trail

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_14ecba91-874e-456e-8147-19fbdc997e6c.jpeg)

﻿[16:48](https://youtu.be/oXcCAAEDte0?t=1008)﻿

An Euler Trail is a trail that visits each Edge in the corresponding graph exactly once. (While such a trail is often referred to as an Euler path it basically isn't a path because it can visit nodes more than once.)

### Euler Circuit

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_adbf5978-7c5a-4c14-a44c-a616ff825a4b.jpeg)

﻿[17:24](https://youtu.be/oXcCAAEDte0?t=1044)﻿

An Euler Circuit is a circuit that visits each Edge in the graph exactly once.
  

﻿[18:00](https://youtu.be/oXcCAAEDte0?t=1080)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_377b85b1-68a5-489e-84b7-341023892bf2.jpeg)

  

﻿[17:36](https://youtu.be/oXcCAAEDte0?t=1056)﻿

One can observe immediately is that the graph in the bottom right corner here which contains an Euler circuit has only nodes with an even degree. And in fact, a graph that contains at least one note with an odd degree cannot have an Euler circuit.

Explanation:

Due to odd degree you wont be able to return to this node anymore (if started here) as required by Euler Circuit.

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_209f62e6-2d11-4caa-8746-d4c8c7305a60.jpeg)

Or even if started from even degree node, we will get stuck in odd degree node as we cannot leave it.

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_ad75ba88-211a-4d80-8c5a-679a1c13b4cc.jpeg)
  

## Euler's Theorems

Assertions:

﻿[19:19](https://youtu.be/oXcCAAEDte0?t=1159)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_873813f6-88a7-48c5-8992-34b9edd34e88.jpeg)
  
## Graph Data Structures

﻿[20:42](https://youtu.be/oXcCAAEDte0?t=1242)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_ce28cd25-1c54-4b83-bb6d-5788b923af23.jpeg)

﻿[21:14](https://youtu.be/oXcCAAEDte0?t=1274)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_a5af6b1b-ad24-4988-a893-5b5c8dbef9c3.jpeg)

  

﻿[21:06](https://youtu.be/oXcCAAEDte0?t=1266)﻿

A graph G is set to be K vertex connected if it contains at least K+1 vertices but does not contain a set of K-1 vertices whose removal disconnects the graph.

  

﻿[22:13](https://youtu.be/oXcCAAEDte0?t=1333)﻿

![](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_563aad7c-f2d0-46bd-903b-975082f844cc.jpeg)

Another important graph is for example the oiler graph which is a graph where every node has an even degree ensuring the existence of an Euler circuit.

  

﻿[22:42](https://youtu.be/oXcCAAEDte0?t=1362)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_2010a74d-f7a2-41b6-968a-13e9565e9f32.jpeg)

Hamilton graph which is a graph that contains a Hamiltonian cycle a cycle that visits each note exactly once.

  

﻿[22:39](https://youtu.be/oXcCAAEDte0?t=1359)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_8ee77f07-8c2a-4b6d-8b31-6c022cd711ac.jpeg)

A bipartite graph is defined as a graph whose notes can be divided into two disjoint sets in such a way that no two nodes within the same set are adjacent in this graph.

Notes this is a bipartite graph without Cycles

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_7b699fa0-230d-496f-86d3-be5f495e2c61.jpeg)

A graph with Cycles can also be Bi-Partite.

  

Furthermore, a graph is in general bipartite if and only if every cycle is even. This means that every cycle in the corresponding graph has to consist of an even number of edges.

  

### Forests

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_fc26af39-c520-4c56-a337-2cf9ebc260dc.jpeg)

A forest describes a collection of trees. Trees are graphs that have always the minimum number of edges necessary for connectivity. A tree will be typically Illustrated with a structure like this.

### Binary Trees

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_a2885953-725d-48b3-948a-f576699b298c.jpeg)

Specifically, this here is a binary (Each node has at most 2 children).

  

﻿[25:34](https://youtu.be/oXcCAAEDte0?t=1534)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_18ba932b-76c7-4a17-9a18-72df391874ff.jpeg)

Binary trees are used in various applications for instance to visualize the execution of many recursive algorithms here for example of the execution of a recursive function that calculates the eight Fibonacci number.

  

﻿[26:09](https://youtu.be/oXcCAAEDte0?t=1569)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_99757905-f9cd-4a7b-8252-491aeaa30f99.jpeg)

Quicksort

### Types of Binary Tree

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_6c2db0b9-c136-49e2-bcdd-6756cc16b398.jpeg)

**The complete binary tree** is characterized by the property that it must be completely filled on every layer of the graph except for the bottom layer and all nodes must be as far left as possible.

In a **full binary tree,** every node has either zero or two children but never just one child. But if a binary tree has only one child per parent either a left or a right child and this through the entire tree then it is called a **degenerated binary tree.**

**The perfect binary tree** is characterized by the property that every layer is completely filled with all leaf nodes on the same layer.


## Basic Data Structures

﻿[27:55](https://youtu.be/oXcCAAEDte0?t=1675)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_cf412349-0ff7-4c30-8c3f-9f138cdfcbc8.jpeg)

﻿[30:06](https://youtu.be/oXcCAAEDte0?t=1806)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_25f4a715-985e-49d9-9552-a8297d7e09b2.jpeg)

﻿[31:44](https://youtu.be/oXcCAAEDte0?t=1904)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_b48930f8-4b84-4c46-a832-d88b57aaaa53.jpeg)

﻿[30:50](https://youtu.be/oXcCAAEDte0?t=1850)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_3c004226-0c17-4697-8816-c95f468e5833.jpeg)

  

﻿[32:41](https://youtu.be/oXcCAAEDte0?t=1961)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_d0243db8-afd4-40b1-afc8-ea796b842abf.jpeg)

**Binary search tree** is a binary tree with the additional property that the key of a parent note is always larger than the key of its left child and smaller or equal to the key of its right child.

  

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_ce1a0498-68ec-4c86-9d12-8bccddacab7f.jpeg)

**The red black tree** guarantees a height that is smaller or equal to $2.\log_2(n+1)$ where n denotes the number of notes in the tree such a tree satisfies the properties in the image.

  

﻿[38:26](https://youtu.be/oXcCAAEDte0?t=2306)﻿

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_54b59ff7-74a6-4933-9ed0-6b71bab1312c.jpeg)

**AVL trees** are binary search trees where the heights of the two child sub trees of any parent nodes differ by at most one. The small indices over the notes in an AVL tree represent the balance factor indicating the height difference between the left and right sub tree of each node. This balancing prevents the tree from a degeneration to maintain efficient search insert and delete operations.

### Heaps

There are two kinds of heaps. Max heaps and mini heaps.

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_29a9848d-d89c-4dda-bd10-23a52aa4457c.jpeg)

**A Max Heap** is a binary tree (but not a binary search tree important) with the property that each node key is greater than or equal to the key of its children.

**A Min Heap** is a binary tree where each node key is less than or equal to the keys of its children.

## Representation of Graph

![Please Reload/Refresh this tab.](https://storage.googleapis.com/askify-screenshot/whBS9pru6UR6eh5u0VbScheduU03/extension_screenshots/screenshot_default_ceebfeea-89ea-48f1-89f0-3c15559af0e9.jpeg)

Adjacency List is more memory efficient.